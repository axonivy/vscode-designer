/**
 * Generated by orval v7.18.0 ðŸº
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { marketFetch } from '../market-fetch';
export interface FeedbackModelRequest {
  /** Product id (from meta.json) */
  productId: string;
  /**
   * User's feedback content
   * @minLength 0
   * @maxLength 250
   */
  content: string;
  /**
   * User's rating point of target product
   * @minimum 1
   * @maximum 5
   */
  rating?: number;
}

export interface Links {[key: string]: Link}

export interface PageMetadata {
  size?: number;
  totalElements?: number;
  totalPages?: number;
  number?: number;
}

export type _PagedModelProductModelEmbedded = {
  products?: ProductModel[];
};

export interface PagedModelProductModel {
  _embedded?: _PagedModelProductModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

/**
 * Product name by locale
 */
export type ProductModelNames = {[key: string]: string};

/**
 * Product's short descriptions by locale
 */
export type ProductModelShortDescriptions = {[key: string]: string};

export interface ProductModel {
  /** Product id */
  id?: string;
  /** Product name by locale */
  names?: ProductModelNames;
  /** Product's short descriptions by locale */
  shortDescriptions?: ProductModelShortDescriptions;
  /** Product's logo url */
  logoUrl?: string;
  /** Type of product */
  type?: string;
  /** Tags of product */
  tags?: string[];
  /** Extension folder directory in market repository */
  marketDirectory?: string;
  _links?: Links;
}

export interface GitHubReleaseModel {
  /** Version of release */
  name?: string;
  /** Body of release */
  body?: string;
  /** Published date of release */
  publishedAt?: string;
  /** Link of release */
  htmlUrl?: string;
  latestRelease?: boolean;
  _links?: Links;
}

/**
 * Product name by locale
 */
export type ProductDetailModelNames = {[key: string]: string};

/**
 * Product's short descriptions by locale
 */
export type ProductDetailModelShortDescriptions = {[key: string]: string};

export interface ProductDetailModel {
  /** Product id */
  id?: string;
  /** Product name by locale */
  names?: ProductDetailModelNames;
  /** Product's short descriptions by locale */
  shortDescriptions?: ProductDetailModelShortDescriptions;
  /** Product's logo url */
  logoUrl?: string;
  /** Type of product */
  type?: string;
  /** Tags of product */
  tags?: string[];
  /** Extension folder directory in market repository */
  marketDirectory?: string;
  /** Product vendor */
  vendor?: string;
  /** Product vendor url */
  vendorUrl?: string;
  /** Product vendor image */
  vendorImage?: string;
  /** Product vendor image dark mode */
  vendorImageDarkMode?: string;
  /** Platform review */
  platformReview?: string;
  /** Latest release version from maven */
  newestReleaseVersion?: string;
  /** Product cost */
  cost?: string;
  /** Source repository url */
  sourceUrl?: string;
  /** Status badge url */
  statusBadgeUrl?: string;
  /** Default language */
  language?: string;
  /** Product industry */
  industry?: string;
  /** Can contact us */
  contactUs?: boolean;
  /** Is deprecated product */
  deprecated?: boolean;
  productModuleContent?: ProductModuleContent;
  /** Installation/download count */
  installationCount?: number;
  /** The api url to get metadata from product.json */
  metaProductJsonUrl?: string;
  /** Compatibility */
  compatibilityRange?: string;
  /** Is the focused product */
  isFocusedProduct?: boolean;
  mavenDropins?: boolean;
  _links?: Links;
}

/**
 * Product detail description content 
 */
export type ProductModuleContentDescription = {[key: string]: string};

/**
 * Setup tab content
 */
export type ProductModuleContentSetup = {[key: string]: string};

/**
 * Demo tab content
 */
export type ProductModuleContentDemo = {[key: string]: string};

export interface ProductModuleContent {
  createdAt?: string;
  updatedAt?: string;
  id?: string;
  /** product Id (from meta.json) */
  productId?: string;
  /** Maven version */
  version?: string;
  /** Product detail description content  */
  description?: ProductModuleContentDescription;
  /** Setup tab content */
  setup?: ProductModuleContentSetup;
  /** Demo tab content */
  demo?: ProductModuleContentDemo;
  /** Is dependency artifact */
  isDependency?: boolean;
  name?: string;
  /** Product artifact's group id */
  groupId?: string;
  /** Product artifact's artifact id */
  artifactId?: string;
  /** Artifact file type */
  type?: string;
}

export interface StreamingResponseBody { [key: string]: unknown }

export interface MavenArtifactKey {
  artifactId?: string;
  productVersion?: string;
  additionalVersion?: boolean;
}

export interface MavenArtifactVersion {
  createdAt?: string;
  updatedAt?: string;
  id?: MavenArtifactKey;
  /** Display name and type of artifact */
  name?: string;
  /** Artifact download url */
  downloadUrl?: string;
  groupId?: string;
  productId?: string;
}

export interface MavenArtifactVersionModel {
  /** Target version */
  version?: string;
  artifactsByVersion?: MavenArtifactVersion[];
}

export type _PagedModelGitHubReleaseModelEmbedded = {
  gitHubReleaseModelList?: GitHubReleaseModel[];
};

export interface PagedModelGitHubReleaseModel {
  _embedded?: _PagedModelGitHubReleaseModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

export interface VersionAndUrlModel {
  version?: string;
  url?: string;
}

export interface DesignerInstallation {
  /** Ivy designer version */
  designerVersion?: string;
  numberOfDownloads?: number;
}

/**
 * Test Status
 */
export type TestStepsModelStatus = typeof TestStepsModelStatus[keyof typeof TestStepsModelStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TestStepsModelStatus = {
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  SKIPPED: 'SKIPPED',
} as const;

/**
 * Workflow type
 */
export type TestStepsModelType = typeof TestStepsModelType[keyof typeof TestStepsModelType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TestStepsModelType = {
  CI: 'CI',
  DEV: 'DEV',
  E2E: 'E2E',
} as const;

export interface TestStepsModel {
  /** Test Name */
  name?: string;
  /** Test Status */
  status?: TestStepsModelStatus;
  /** Workflow type */
  type?: TestStepsModelType;
}

export interface GithubReposModel {
  /** Repository name */
  repoName?: string;
  /** Product id */
  productId?: string;
  /** Repository HTML URL */
  htmlUrl?: string;
  workflowInformation?: WorkflowInformation[];
  /** Indicates if the repository is a focused repository */
  focused?: boolean;
  /** Test results summary by workflow type and test environment */
  testResults?: TestResults[];
}

export type _PagedModelGithubReposModelEmbedded = {
  githubRepos?: GithubReposModel[];
};

export interface PagedModelGithubReposModel {
  _embedded?: _PagedModelGithubReposModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

export type TestResultsWorkflow = typeof TestResultsWorkflow[keyof typeof TestResultsWorkflow];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TestResultsWorkflow = {
  CI: 'CI',
  DEV: 'DEV',
  E2E: 'E2E',
} as const;

export type TestResultsResults = {[key: string]: number};

/**
 * Test results summary by workflow type and test environment
 */
export interface TestResults {
  workflow?: TestResultsWorkflow;
  results?: TestResultsResults;
}

export type WorkflowInformationWorkflowType = typeof WorkflowInformationWorkflowType[keyof typeof WorkflowInformationWorkflowType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkflowInformationWorkflowType = {
  CI: 'CI',
  DEV: 'DEV',
  E2E: 'E2E',
} as const;

export interface WorkflowInformation {
  id?: string;
  workflowType?: WorkflowInformationWorkflowType;
  lastBuilt?: string;
  conclusion?: string;
  lastBuiltRunUrl?: string;
  currentWorkflowState?: string;
  disabledDate?: string;
}

export interface Image {
  id?: string;
  /** Product id */
  productId?: string;
  /** The download url from github */
  imageUrl?: string;
  /** The image content as byte array */
  imageData?: string[];
  /** The SHA from github */
  sha?: string;
}

/**
 * Product name (from meta.json)
 */
export type FeedbackModelProductNames = {[key: string]: string};

/**
 * User's feedback status
 */
export type FeedbackModelFeedbackStatus = typeof FeedbackModelFeedbackStatus[keyof typeof FeedbackModelFeedbackStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackModelFeedbackStatus = {
  APPROVED: 'APPROVED',
  PENDING: 'PENDING',
  REJECTED: 'REJECTED',
} as const;

export interface FeedbackModel {
  /** Id of feedback */
  id?: string;
  /** User Id */
  userId?: string;
  /** Github username */
  username?: string;
  /** Url of github avatar */
  userAvatarUrl?: string;
  /** 3rd party login provider */
  userProvider?: string;
  /** Product id (from meta.json) */
  productId?: string;
  /** Product name (from meta.json) */
  productNames?: FeedbackModelProductNames;
  /** User's feedback content */
  content?: string;
  /**
   * User's rating point of target product
   * @minimum 1
   * @maximum 5
   */
  rating?: number;
  /** Feedback/rating creating timestamp */
  createdAt?: string;
  /** Latest feedback/rating updating timestamp */
  updatedAt?: string;
  /** User's feedback status */
  feedbackStatus?: FeedbackModelFeedbackStatus;
  /** Moderator name reviewed feedback */
  moderatorName?: string;
  /** Feedback reviewing timestamp */
  reviewDate?: string;
  /** Feedback modification version */
  version?: number;
  /** Is latest approved or pending feedback */
  isLatest?: boolean;
  _links?: Links;
}

export type _PagedModelFeedbackModelEmbedded = {
  feedbacks?: FeedbackModel[];
};

export interface PagedModelFeedbackModel {
  _embedded?: _PagedModelFeedbackModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

export interface ProductRating {
  /** Specific rating point of product */
  starRating?: number;
  /** Count of rating on this specific point */
  commentNumber?: number;
  /** Weight ration of this point/ total point */
  percent?: number;
}

export interface ExternalDocumentModel {
  /** Product id */
  productId?: string;
  /** Name of artifact */
  artifactName?: string;
  /** Version of artifact */
  version?: string;
  /** Relative link of document page */
  relativeLink?: string;
  _links?: Links;
}

export interface DocumentInfoResponse {
  versions?: DocumentVersion[];
  languages?: DocumentLanguage[];
}

export interface DocumentLanguage {
  language?: string;
  url?: string;
}

export interface DocumentVersion {
  version?: string;
  url?: string;
}

export interface Link {
  href?: string;
  hreflang?: string;
  title?: string;
  type?: string;
  deprecation?: string;
  profile?: string;
  name?: string;
  templated?: boolean;
}

export type FindProductsParams = {
/**
 * Page number to retrieve
 * @minimum 0
 */
page: number;
/**
 * Number of items per page
 * @minimum 1
 */
size?: number;
/**
 * Sorting criteria in the format: Sorting criteria(popularity|alphabetically|recent), Sorting order(asc|desc)
 */
sort: string[];
/**
 * Type of product.
 */
type: FindProductsType;
/**
 * Keyword that exist in product's name or short description
 */
keyword?: string;
/**
 * Language of product short description
 */
language: FindProductsLanguage;
/**
 * Option to render the website in the REST Client Editor of Designer
 */
isRESTClient: boolean;
};

export type FindProductsType = typeof FindProductsType[keyof typeof FindProductsType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindProductsType = {
  all: 'all',
  connectors: 'connectors',
  utilities: 'utilities',
  solutions: 'solutions',
  demos: 'demos',
} as const;

export type FindProductsLanguage = typeof FindProductsLanguage[keyof typeof FindProductsLanguage];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindProductsLanguage = {
  en: 'en',
  de: 'de',
} as const;

export type FindProductDetailsParams = {
/**
 * Option to get Dev Version (Snapshot/ sprint release)
 */
isShowDevVersion?: boolean;
};

export type FindProductJsonContentParams = {
designerVersion?: string;
};

export type FindProductJsonContent200 = {[key: string]: { [key: string]: unknown }};

export type FindBestMatchVersionParams = {
/**
 * Option to get Dev Version (Snapshot/ sprint release)
 */
isShowDevVersion?: boolean;
};

export type FindProductVersionsByIdParams = {
/**
 * Option to get Dev Version (Snapshot/ sprint release)
 */
isShowDevVersion: boolean;
designerVersion?: string;
};

export type FindGithubPublicReleasesParams = {
/**
 * Page number to retrieve
 * @minimum 0
 */
page: number;
/**
 * Number of items per page
 * @minimum 1
 */
size?: number;
/**
 * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 */
sort?: string[];
};

export type FindVersionsForDesignerParams = {
designerVersion?: string;
/**
 * Option to get Dev Version (Snapshot/ sprint release)
 */
isShowDevVersion: boolean;
};

export type GetLatestArtifactDownloadUrlParams = {
version: string;
artifact: string;
};

/**
 * By default, the system finds products with type 'all'
 * @summary Retrieve a paginated list of all products, optionally filtered by type, keyword, and language
 */
export type findProductsResponse200 = {
  data: PagedModelProductModel
  status: 200
}
    
export type findProductsResponseSuccess = (findProductsResponse200) & {
  headers: Headers;
};
;

export type findProductsResponse = (findProductsResponseSuccess)

export const getFindProductsUrl = (params: FindProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product?${stringifiedParams}` : `/api/product`
}

export const findProducts = async (params: FindProductsParams, options?: RequestInit): Promise<findProductsResponse> => {
  
  return marketFetch<findProductsResponse>(getFindProductsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Get release by product id and release id
 * @summary Find release by product id and release id
 */
export type findGithubPublicReleaseByProductIdAndReleaseIdResponse200 = {
  data: GitHubReleaseModel
  status: 200
}
    
export type findGithubPublicReleaseByProductIdAndReleaseIdResponseSuccess = (findGithubPublicReleaseByProductIdAndReleaseIdResponse200) & {
  headers: Headers;
};
;

export type findGithubPublicReleaseByProductIdAndReleaseIdResponse = (findGithubPublicReleaseByProductIdAndReleaseIdResponseSuccess)

export const getFindGithubPublicReleaseByProductIdAndReleaseIdUrl = (productId: string,
    releaseId: number,) => {


  

  return `/api/product-details/${productId}/releases/${releaseId}`
}

export const findGithubPublicReleaseByProductIdAndReleaseId = async (productId: string,
    releaseId: number, options?: RequestInit): Promise<findGithubPublicReleaseByProductIdAndReleaseIdResponse> => {
  
  return marketFetch<findGithubPublicReleaseByProductIdAndReleaseIdResponse>(getFindGithubPublicReleaseByProductIdAndReleaseIdUrl(productId,releaseId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Return product detail by product id (from meta.json)
 * @summary get product detail by ID
 */
export type findProductDetailsResponse200 = {
  data: ProductDetailModel
  status: 200
}
    
export type findProductDetailsResponseSuccess = (findProductDetailsResponse200) & {
  headers: Headers;
};
;

export type findProductDetailsResponse = (findProductDetailsResponseSuccess)

export const getFindProductDetailsUrl = (id: string,
    params?: FindProductDetailsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}?${stringifiedParams}` : `/api/product-details/${id}`
}

export const findProductDetails = async (id: string,
    params?: FindProductDetailsParams, options?: RequestInit): Promise<findProductDetailsResponse> => {
  
  return marketFetch<findProductDetailsResponse>(getFindProductDetailsUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * get product detail by it product id and release version
 * @summary Find product detail by product id and release version.
 */
export type findProductDetailsByVersionResponse200 = {
  data: ProductDetailModel
  status: 200
}
    
export type findProductDetailsByVersionResponseSuccess = (findProductDetailsByVersionResponse200) & {
  headers: Headers;
};
;

export type findProductDetailsByVersionResponse = (findProductDetailsByVersionResponseSuccess)

export const getFindProductDetailsByVersionUrl = (id: string,
    version: string,) => {


  

  return `/api/product-details/${id}/${version}`
}

export const findProductDetailsByVersion = async (id: string,
    version: string, options?: RequestInit): Promise<findProductDetailsByVersionResponse> => {
  
  return marketFetch<findProductDetailsByVersionResponse>(getFindProductDetailsByVersionUrl(id,version),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * When we click install in designer, this API will send content of product json for installing in Ivy designer
 * @summary Get product json content for designer to install
 */
export type findProductJsonContentResponse200 = {
  data: FindProductJsonContent200
  status: 200
}
    
export type findProductJsonContentResponseSuccess = (findProductJsonContentResponse200) & {
  headers: Headers;
};
;

export type findProductJsonContentResponse = (findProductJsonContentResponseSuccess)

export const getFindProductJsonContentUrl = (id: string,
    version: string,
    params?: FindProductJsonContentParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/${version}/json?${stringifiedParams}` : `/api/product-details/${id}/${version}/json`
}

export const findProductJsonContent = async (id: string,
    version: string,
    params?: FindProductJsonContentParams, options?: RequestInit): Promise<findProductJsonContentResponse> => {
  
  return marketFetch<findProductJsonContentResponse>(getFindProductJsonContentUrl(id,version,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * get product detail by it product id and version
 * @summary Find best match product detail by product id and version.
 */
export type findBestMatchProductDetailsByVersionResponse200 = {
  data: ProductDetailModel
  status: 200
}
    
export type findBestMatchProductDetailsByVersionResponseSuccess = (findBestMatchProductDetailsByVersionResponse200) & {
  headers: Headers;
};
;

export type findBestMatchProductDetailsByVersionResponse = (findBestMatchProductDetailsByVersionResponseSuccess)

export const getFindBestMatchProductDetailsByVersionUrl = (id: string,
    version: string,) => {


  

  return `/api/product-details/${id}/${version}/bestmatch`
}

export const findBestMatchProductDetailsByVersion = async (id: string,
    version: string, options?: RequestInit): Promise<findBestMatchProductDetailsByVersionResponse> => {
  
  return marketFetch<findBestMatchProductDetailsByVersionResponse>(getFindBestMatchProductDetailsByVersionUrl(id,version),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * get best match version by id and version
 * @summary Find best match version.
 */
export type findBestMatchVersionResponse200 = {
  data: string
  status: 200
}
    
export type findBestMatchVersionResponseSuccess = (findBestMatchVersionResponse200) & {
  headers: Headers;
};
;

export type findBestMatchVersionResponse = (findBestMatchVersionResponseSuccess)

export const getFindBestMatchVersionUrl = (id: string,
    version: string,
    params?: FindBestMatchVersionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/${version}/best-match-version?${stringifiedParams}` : `/api/product-details/${id}/${version}/best-match-version`
}

export const findBestMatchVersion = async (id: string,
    version: string,
    params?: FindBestMatchVersionParams, options?: RequestInit): Promise<findBestMatchVersionResponse> => {
  
  return marketFetch<findBestMatchVersionResponse>(getFindBestMatchVersionUrl(id,version,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Return the download url of artifact from version and id
 * @summary Get the download steam of artifact and it's dependencies by it's id and target version
 */
export type downloadZipArtifactResponse200 = {
  data: StreamingResponseBody
  status: 200
}
    
export type downloadZipArtifactResponseSuccess = (downloadZipArtifactResponse200) & {
  headers: Headers;
};
;

export type downloadZipArtifactResponse = (downloadZipArtifactResponseSuccess)

export const getDownloadZipArtifactUrl = (id: string,
    artifactId: string,
    version: string,) => {


  

  return `/api/product-details/${id}/${artifactId}/${version}/zip-file`
}

export const downloadZipArtifact = async (id: string,
    artifactId: string,
    version: string, options?: RequestInit): Promise<downloadZipArtifactResponse> => {
  
  return marketFetch<downloadZipArtifactResponse>(getDownloadZipArtifactUrl(id,artifactId,version),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Get all product versions by product id
 * @summary Get product versions by product id
 */
export type findProductVersionsByIdResponse200 = {
  data: MavenArtifactVersionModel[]
  status: 200
}
    
export type findProductVersionsByIdResponseSuccess = (findProductVersionsByIdResponse200) & {
  headers: Headers;
};
;

export type findProductVersionsByIdResponse = (findProductVersionsByIdResponseSuccess)

export const getFindProductVersionsByIdUrl = (id: string,
    params: FindProductVersionsByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/versions?${stringifiedParams}` : `/api/product-details/${id}/versions`
}

export const findProductVersionsById = async (id: string,
    params: FindProductVersionsByIdParams, options?: RequestInit): Promise<findProductVersionsByIdResponse> => {
  
  return marketFetch<findProductVersionsByIdResponse>(getFindProductVersionsByIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Get all public releases by product id
 * @summary Find public releases by product id
 */
export type findGithubPublicReleasesResponse200 = {
  data: PagedModelGitHubReleaseModel
  status: 200
}
    
export type findGithubPublicReleasesResponseSuccess = (findGithubPublicReleasesResponse200) & {
  headers: Headers;
};
;

export type findGithubPublicReleasesResponse = (findGithubPublicReleasesResponseSuccess)

export const getFindGithubPublicReleasesUrl = (id: string,
    params: FindGithubPublicReleasesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/releases?${stringifiedParams}` : `/api/product-details/${id}/releases`
}

export const findGithubPublicReleases = async (id: string,
    params: FindGithubPublicReleasesParams, options?: RequestInit): Promise<findGithubPublicReleasesResponse> => {
  
  return marketFetch<findGithubPublicReleasesResponse>(getFindGithubPublicReleasesUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Collect the released versions in product for ivy designer
 * @summary Get the list of released version in product
 */
export type findVersionsForDesignerResponse200 = {
  data: VersionAndUrlModel[]
  status: 200
}
    
export type findVersionsForDesignerResponseSuccess = (findVersionsForDesignerResponse200) & {
  headers: Headers;
};
;

export type findVersionsForDesignerResponse = (findVersionsForDesignerResponseSuccess)

export const getFindVersionsForDesignerUrl = (id: string,
    params: FindVersionsForDesignerParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/designerversions?${stringifiedParams}` : `/api/product-details/${id}/designerversions`
}

export const findVersionsForDesigner = async (id: string,
    params: FindVersionsForDesignerParams, options?: RequestInit): Promise<findVersionsForDesignerResponse> => {
  
  return marketFetch<findVersionsForDesignerResponse>(getFindVersionsForDesignerUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Return the download url of artifact from version and id
 * @summary Get the download url of latest version from artifact by its id and target version
 */
export type getLatestArtifactDownloadUrlResponse200 = {
  data: string
  status: 200
}
    
export type getLatestArtifactDownloadUrlResponseSuccess = (getLatestArtifactDownloadUrlResponse200) & {
  headers: Headers;
};
;

export type getLatestArtifactDownloadUrlResponse = (getLatestArtifactDownloadUrlResponseSuccess)

export const getGetLatestArtifactDownloadUrlUrl = (id: string,
    params: GetLatestArtifactDownloadUrlParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/artifact?${stringifiedParams}` : `/api/product-details/${id}/artifact`
}

export const getLatestArtifactDownloadUrl = async (id: string,
    params: GetLatestArtifactDownloadUrlParams, options?: RequestInit): Promise<getLatestArtifactDownloadUrlResponse> => {
  
  return marketFetch<getLatestArtifactDownloadUrlResponse>(getGetLatestArtifactDownloadUrlUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Sync latest releases from GitHub for all products
 * @summary Sync latest releases from GitHub for all products
 */
export type syncLatestReleasesForProductsResponse200 = {
  data: void
  status: 200
}
    
export type syncLatestReleasesForProductsResponseSuccess = (syncLatestReleasesForProductsResponse200) & {
  headers: Headers;
};
;

export type syncLatestReleasesForProductsResponse = (syncLatestReleasesForProductsResponseSuccess)

export const getSyncLatestReleasesForProductsUrl = () => {


  

  return `/api/product-details/sync-release-notes`
}

export const syncLatestReleasesForProducts = async ( options?: RequestInit): Promise<syncLatestReleasesForProductsResponse> => {
  
  return marketFetch<syncLatestReleasesForProductsResponse>(getSyncLatestReleasesForProductsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
